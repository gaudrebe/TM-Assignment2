import os
import numpy as np
from nltk.tokenize import word_tokenize
"""
Bigram Language Model
@author Ben Gaudreau
@version 23 Feb 2024
"""

class BigramModel:
    """
    Construct a new bigram language model with the given corpus. The corpus
    should be a file path to a folder containing songs of a particular genre.
    """
    def __init__(self, corpus):
        dicts = self.buildGenreDicts(corpus)
        self.termFrequency = dicts[0]
        self.pairFrequency = dicts[1]
        return

    """
    Returns the probability of this bigram language model producing inputText.
    """
    def test(self, inputText):
        return self.calculateProbability(inputText)


    """
    Converts a string into a list of 2-tuples of the form (A, B) such that A is a
    word, and B is the word preceding A.
    """
    def pairWords(self, line: str) -> list:
        pairs = []
        tokens = word_tokenize(line)
        for i, token in enumerate(tokens):
            if (i == 0):
                pairs.append((token, "<s>"))
            else:
                pairs.append((token, tokens[i-1]))
            if (i == len(tokens)-1):
                pairs.append(("</s>", token))
        return pairs

    """
    Given a folder containing songs of one genre, returns a 2-tuple of dictionaries
    of the form (A, B) such that A is a dictionary whose keys represent tokens with
    value equal to that token's frequency, and that B is a dictionary whose keys
    represent pairs of tokens with value equal to that pair's frequency.
    """
    def buildGenreDicts(self, path: str) -> tuple:
        termFrequency = {}
        pairFrequency = {}
        for file in os.listdir(path):
            with open(path + file, 'r') as rfile:
                for line in rfile:
                    currLine = str.lower(line.strip())
                    pairs = self.pairWords(currLine)
                    for pair in pairs:
                        token = pair[0]
                        if (token not in termFrequency):
                            termFrequency.update({token:1})
                        else:
                            termFrequency[token] += 1
                        if (pair not in pairFrequency):
                            pairFrequency.update({pair:1})
                        else:
                            pairFrequency[pair] += 1
        return termFrequency, pairFrequency

    """
    Given the term and pair frequency dictionaries of songs from a genre of music
    (a classifier for that genre), returns the probability of inputText being
    generated by that genre's model.
    """
    def calculateProbability(self, inputText: str) -> float:
        genreProb = np.float64(0.0)
        genreTF = self.termFrequency
        genrePF = self.pairFrequency
        vocabSize = len(genreTF)
        # preprocess input
        text = str.lower(inputText.strip())
        textPairs = self.pairWords(text)
        # calculate and sum log probabilities for each pair
        for pair in textPairs:
            prevCount = genreTF.get(pair[1], 0)
            pairCount = genrePF.get(pair, 0)
            pairProb = np.log10((pairCount + 1) / (prevCount + vocabSize))
            genreProb += pairProb
        return 10**genreProb

"""
For each folder of training data in directory, create a bigram language model
and return them all in a list.
"""
def buildModels(directory):
    # training data directory
    models = {}
    # build unigram models for each genre
    for genre in os.listdir(directory):
        songs = os.path.join(directory, directory + genre + "\\")
        model = BigramModel(songs)
        models.update({genre:model})
    return models

"""
For all biigram language models in a list, calculate and print the probability
for inputText to be generated by that model.
"""
def testModels(models, inputText):
    max = 0
    result = ""
    for genre in models:
        genreProb = models[genre].test(inputText)
        if (genreProb > max):
            result = genre
            max = genreProb
    return result